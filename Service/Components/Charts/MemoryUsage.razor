@using Common.State.MemoryUsage;
@inject IState<MemoryUsageState> loadState

<RadzenChart>
    <RadzenLineSeries Smooth="false" Data="@_memoryUsage" CategoryProperty="Index" Title="Memory Usage (MB)" LineType="LineType.Solid" ValueProperty="UsageDenomination">
        <RadzenMarkers MarkerType="MarkerType.Square" />
        <RadzenLegend Visible="false" />
        <RadzenCategoryAxis Visible=false />
        <RadzenValueAxis FormatString="{0:0.##}"/>
    </RadzenLineSeries>
</RadzenChart>

@code {
    private class Usage
    {
        public uint UsageBytes { get; }
        public static int TotalIndex { get; set; } = 0;
        public int Index { get; set; }

        public double UsageDenomination
        {
            get
            {
                uint bytes = UsageBytes;
                int i;
                double dblSByte = bytes;
                for (i = 0; i < 3 && bytes >= 1024; i++, bytes /= 1024)
                {
                    dblSByte = bytes / 1024.0;
                }

                return dblSByte;
            }
        }

        public Usage(uint usage)
        {
            UsageBytes = usage;
            Index = TotalIndex++;
        }
    }

    List<Usage> _memoryUsage = new();

    protected override void OnInitialized()
    {
        base.OnInitialized();

        loadState.StateChanged += (_, _) =>
        {
            // If less than 1MB we do not care, probably starting up
            if (loadState.Value.MemoryUsageBytes < 1000000u)
            {
                return;
            }

            _memoryUsage.Add(new(loadState.Value.MemoryUsageBytes));
            InvokeAsync(StateHasChanged);
        };
    }
}
